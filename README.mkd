Two levels:
  - Goals
  - Behaviours

Goals are assigned a score at each tick.
If the entity already has a goal then that goal gets bonus points towards it.
Goals are selected at random with probability weighted (nonlinearly) by score.

Once assigned a goal, the entity will follow a behaviour tree in order to try to achieve it.

All behaviours can be interrupted instantly.
Goals can be interrupted.


Once the behaviour tree for a goal finishes the entity (becomes idle | loops)





tt_behaviour_selector(
    tt_behaviour_sequence(
        tt_behaviour_walk_to_door(NULL),
        tt_behaviour_selector(
            tt_behaviour_open_door(NULL),
            tt_behaviour_sequence(
                tt_behaviour_unlock_door(NULL),
                tt_behaviour_open_door(NULL),
                NULL
            ),
            tt_behaviour_smash_door(NULL),
            NULL
        ),
        NULL
    ),
    NULL
)
















selector
  sequence
    walk-to-door
    selector
      open-door
      sequence
        unlock-door
        open-door
      smash-door
    walk-through-door
    close-door



sequence
  # Get wood.
  selector-until
    inventory-full

    # Get wood from existing pile.
    sequence
      select-wood-pile
      walk-to-target
      harvest-target

    # Get wood by chopping down tree.
    sequence
      selector
        get-axe

      select-tree
      walk-to-target
      harvest-target

  # Drop wood at stockpile.
  select-stockpile
  walk-to-target






goals:
  - Get wood
  - Harvest crops
  - Construct building
  - Flee
  - Attack enemy













systems:
  -


components:
  job
  harvestable


jobs:
  - Harvest
  - C




collect:
  if not inventory_full():
    if not target:
      target = choose_target(self, is_harvestable)

    if range(self, target) < min:
      collect()

  else:
    if not target:
      target = choose_stockpile(self, is_stockpile)

    if not target:
      clear_job()

    if range(self, target) < min:
      deposit()

